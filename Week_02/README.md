学习笔记

### GC(garbage collector) 总结

1. 串行 (Serial) GC
   * 使用单线程处理所有垃圾回收工作，因为无需多线程交互，所以效率比较高。但是，也无法使用多处理器的优势，所以此收集器适合单处理器机器
   * -XX:+UseSerialGC
2. 并行 (Parallel) GC 
   * 对年轻代进行并行垃圾回收，因此可以减少垃圾回收时间。一般在多线程多处理器机器上使用
   * -XX:+UseParallelGC
   * Java 8 及之后版本默认 GC
3. 并发 (Concurrent) GC
   * 并发标记清除（Concurrent Mark Sweep）收集器 CMS
   * 可以保证大部分工作都并发进行，垃圾回收只暂停很少的时间，此收集器适合对响应时间要求比较高的中、大规模应用
   * -XX:+UseConcMarkSweepGC
4. G1 GC
   * JDK1.7中正式使用的全新垃圾回收器，G1拥有独特的垃圾回收策略
   * 特色
     * 首先收集尽可能多的垃圾
     * 内存分区(Region)的思路，将内存划分为一个个相等大小的内存分区，回收时则以分区为单位进行回收，存活的对象复制到另一个空闲分区中，由于都是以相等大小的分区为单位进行操作，因此G1天然就是一种压缩方案(局部压缩)
     * G1虽然也是分代收集器，但整个内存分区不存在物理上的年轻代与老年代的区别，也不需要完全独立的survivor(to space)堆做复制准备。G1只有逻辑上的分代概念，或者说每个分区都可能随G1的运行在不同代之间前后切换
     * G1的收集都是STW的，但年轻代和老年代的收集界限比较模糊，采用了混合(mixed)收集的方式。即每次收集既可能只收集年轻代分区(年轻代收集)，也可能在收集年轻代的同时，包含部分老年代分区(混合收集)，这样即使堆内存很大时，也可以限制收集范围，从而降低停顿
   * 收集过程
     * 新生代GC
     * 并发标记周期
     * 混合收集
     * 进行Full GC
   * -XX:+UseG1GC